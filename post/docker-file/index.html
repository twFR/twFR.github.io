<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>docker | 🌟谭先生✨</title>
<link rel="shortcut icon" href="https://twFR.github.io/favicon.ico?v=1610877076140">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://twFR.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://twFR.github.io">
  <img class="avatar" src="https://twFR.github.io/images/avatar.png?v=1610877076140" alt="">
  </a>
  <h1 class="site-title">
    🌟谭先生✨
  </h1>
  <p class="site-description">
    敲不出代码的程序猿的🏠
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
        <a href="https://www.facebook.com/xin.tan.106902" target="_blank">
          <i class="fab fa-facebook"></i>
        </a>
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              docker
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-04-07 ·
              </time>
              
                <a href="https://twFR.github.io/tag/5HlJA4urI/" class="post-tag">
                  # k8s
                </a>
              
            </div>
            
            <div class="post-content">
              <blockquote>
<p>reference: <a href="https://docs.docker.com/engine/reference/builder/">docker官方文档</a></p>
</blockquote>
<h2 id="dockerfile">dockerfile</h2>
<ul>
<li>dockerfile必须以<code>FROM</code>指令开始。<code>ARG</code>是唯一可以早于<code>FROM</code>执行的指令，查看<a href="#interact">ARG和FROM的交互</a></li>
<li>dockerfile中以<code>#</code>来标示注释，注释会在dockerfile被执行前移除掉，以免对命令产生影响</li>
</ul>
<h3 id="解析器指令">解析器指令</h3>
<p>解析器指令放在最上面，以<code># directive=value</code>的形式来声明，一旦注释 空行或者builder指令执行，docker就不会再去招解析器指令，而是把它当成注释。<br>
下面几种是不符合规范的场景：</p>
<pre><code># direc \  
 tive=value
</code></pre>
<p>△ 换行不符合规范</p>
<pre><code># directive=value1
# directive=value2
FROM ImageName
</code></pre>
<p>△ 出现两次</p>
<pre><code>FROM ImageName
# directive=value
</code></pre>
<p>△ 在builder指令后面，会被认为是注释</p>
<pre><code># About my dockerfile
# directive=value
FROM ImageName
</code></pre>
<p>△ 在注释后面，会被认为是注释</p>
<pre><code># unknowndirective=value
# knowndirective=value
</code></pre>
<p>△ 未知的解释器指令，会被认为是注释，第二行同样会被认为是注释</p>
<pre><code>#directive=value
# directive =value
#	directive= value
# directive = value
#	  dIrEcTiVe=value
</code></pre>
<p>△ 上面几种写法会被认为是同一种写法，即无视空格，不区分大小写</p>
<p>支持的解释器指令</p>
<ul>
<li>syntax<br>
# syntax=[remote image reference]<br>
这是用buldkit才会使用到的，为了指定构建当前dokcerfile的dokcerfile构建器的位置</li>
<li>escape<br>
# escape=\ (backslash) || # escape=` (backtick)<br>
escape定义转义字符，转义字符不会在<code>RUN</code>指令中执行<br>
例如在windows中将转义字符设置成`  很有用，因为windows目录格式是<code>C:\\</code>，但是在dockerfile里面会解析成<code>C:\</code>，就会找不到对应目录</li>
</ul>
<h3 id="环境变量">环境变量</h3>
<p>环境变量以$variable_name 或者 ${variable_name}格式，同样支持以下bash风格的格式：</p>
<ul>
<li>${variable:-word}  如果<code>veriable</code>设置了值，结果就是这个值。如果没有，就是<code>word</code>结果，<code>word</code>可以是定值也可以是其他变量</li>
<li>${variable:+word}  如果<code>veriable</code>设置了值，结果就是<code>word</code>。如果没有，就是空<br>
如下示例：</li>
</ul>
<pre><code>ENV abc=hello
ENV abc=bye def=$abc
ENV ghi=$abc
</code></pre>
<p><code>def</code>的值为<code>hello</code>，而 <code>ghi</code>值为<code>bye</code>官方是如下解释的</p>
<blockquote>
<p>Environment variable substitution will use the same value for each variable throughout the entire instruction. In other words</p>
</blockquote>
<p>讲道理没看特明白，但是个人土味理解应该是说每行算一个<code>entire instruction</code>,这行的值都是不会变化的，所以<code>def</code>还是用的上一行的<code>hello</code>值，而<code>ghi</code> 则可以取到上一行执行后的结果</p>
<h3 id="dockerignore-file">.dockerignore file</h3>
<p><code>.dockerignore</code> file其实和git里面的.<code>gitignore</code>文件类似，docker CLI在发送context的时候会先寻找这个文件，然后将这个文件和文件里面的指定模式的文件去除掉，不发送给docker daemon。需要注意的是<code>!</code>这个符号的用法：</p>
<pre><code>*.md                       //去掉所有md结尾的文件
!README*.md          //README开头的md文件不去除
README-secret.md  // README-secret.md作为特例要去除
</code></pre>
<p>这里表示去掉所有markdown文件。但是不去除README相关的文件，除了README-secret.md这个文件</p>
<h3 id="from">FROM</h3>
<p>三种格式：</p>
<pre><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]
</code></pre>
<pre><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]
</code></pre>
<pre><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]
</code></pre>
<p><code>FROM</code>开始一个构建阶段，并且指定后面刚好构建指令的基础镜像</p>
<ul>
<li><code>FROM</code>可以在一个dokcerfile里面出现多次，构建多个构建镜像。只要在下一次<code>FROM</code>指令之前记住上一次image ID，两次构建就可以相互用来。每次<code>FROM</code>指令开始会清除上一次的指令</li>
<li><code>AS name</code>是可选的，如果使用了，可以在下一次的<code>FROM</code>使用 <code>COPY --from=&lt;name&gt;</code>来关联上一次的构建镜像</li>
<li><code>tag</code>和<code>digest</code>也是可选的，默认为<code>latest</code></li>
</ul>
<h4 id="a-nameinteractarg和from的交互a"><a name="interact">ARG和FROM的交互</a></h4>
<p>FROM的变量是通过ARG来定义的，所以ARG是有可能先于FROM执行的，但是此时ARG是在构建阶段之外定义的，只能在FROM指令里面使用，在其他指令使用需要在执行一次没有值的ARG</p>
<pre><code>ARG VERSION=latest
FROM busybox:$VERSION
ARG VERSION     //空值ARG取上一次ARG的值
RUN echo $VERSION &gt; image_version
</code></pre>
<h3 id="run">RUN</h3>
<p>两种格式：</p>
<pre><code>RUN &lt;command&gt;(shell form,the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows))
</code></pre>
<pre><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)
</code></pre>
<p>RUN指令将在当前layer顶部的新layer执行命令，提交结果，生成的镜像将用于dockerfile下一步<br>
例：</p>
<pre><code>RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'
</code></pre>
<pre><code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]  //execform 是解析称json数组的，所以只能用&quot;，不能用'
</code></pre>
<p>execform不会调用shell，如RUN[&quot;echo,&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">&quot;</mi><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">不</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">在</mi></mrow><annotation encoding="application/x-tex">HOME&quot;],不会在</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">&quot;</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">在</span></span></span></span>HOME上进行变量替换。要执行shell，需要这样：RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]。当使用execform并直接执行shell时（例如在shell表单中），是由shell进行环境变量扩展，而不是docker。<br>
RUN指令的缓存不会自动失效。 诸如RUN apt-get dist-upgrade -y之类的指令的存将在下一个构建期间重用。 可以使用--no-cache标志使RUN指令的缓存无效，例如docker build --no-cache</p>
<h3 id="cmd">CMD</h3>
<p>三种格式：</p>
<pre><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)
</code></pre>
<pre><code>CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT) //使用JSON数组格式指定，即只能使用 &quot;,不能使用'
</code></pre>
<pre><code>CMD command param1 param2 (shell form)   //在/ bin / sh -c中执行
</code></pre>
<p>CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也将终止；不过， CMD指定的命令其可以被 docker run的命令行选项所覆盖 .在Dockerfile中可以存在多个 CMD指令，但仅最后一个会生效<br>
如果用户为docker run指定了参数，则它们将覆盖CMD中指定的默认值</p>
<h4 id="run和cmd的区别">RUN和CMD的区别</h4>
<blockquote>
<p>Do not confuse RUN with CMD. RUN actually runs a command and commits the result; CMD does not execute anything at build time, but specifies the intended command for the image.<br>
RUN执行了命令并提交了结果，但是CMD在build期间没有执行热河东西，但是为镜像指定了预期的命令</p>
</blockquote>
<h3 id="entrypoint">ENTRYPOINT</h3>
<p>两种格式：</p>
<pre><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)
</code></pre>
<pre><code>ENTRYPOINT command param1 param2 (shell form)
</code></pre>
<p>类似 CMD指令的功能，用于为容器指定默认运行程序，从而使得容器像是一个单独的可执行程序</p>
<p>与CMD不同的是，由 ENTRYPOINT启动的程序不会被 docker run命令行指定的参数所覆盖，而且，这些命令行参数会被当作参数传递给 ENTRYPOINT指定指定的程序 ,ocker run 命令传入的命令参数会覆盖CMD指令的内容并且附加到ENTRYPOINT命令最后做为其参数使用, docker run命令的 --entrypoint选项的参数可覆盖ENTRYPOINT指令指定的程序<br>
Dockerfile文件中也可以存在多个 ENTRYPOINT指令，但仅有最后一个会生效</p>
<h4 id="cmd和entyypoint交互">CMD和ENTYYPOINT交互</h4>
<p>Dockerfile应该指定CMD或ENTRYPOINT命令中的至少一个。<br>
使用容器作为可执行文件时，应定义ENTRYPOINT。<br>
CMD应该用作定义ENTRYPOINT命令或在容器中执行临时命令的默认参数的方式。<br>
下表显示了针对不同ENTRYPOINT / CMD组合执行的命令：</p>
<table>
<thead>
<tr>
<th></th>
<th>No ENTRYPOINT</th>
<th>ENTRYPOINT exec_entry p1_entry</th>
<th>ENTRYPOINT [“exec_entry”, “p1_entry”]</th>
</tr>
</thead>
<tbody>
<tr>
<td>No CMD</td>
<td>error, not allowed</td>
<td>/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry</td>
</tr>
<tr>
<td>CMD [“exec_cmd”, “p1_cmd”]</td>
<td>exec_cmd p1_cmd</td>
<td>/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry exec_cmd p1_cmd</td>
</tr>
<tr>
<td>CMD [“p1_cmd”, “p2_cmd”]</td>
<td>p1_cmd p2_cmd</td>
<td>/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry p1_cmd p2_cmd</td>
</tr>
<tr>
<td>CMD exec_cmd p1_cmd</td>
<td>/bin/sh -c exec_cmd p1_cmd</td>
<td>/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd</td>
</tr>
</tbody>
</table>
<h3 id="copy">COPY</h3>
<p>两种形式</p>
<pre><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]  //在路径中有空白字符时通常使用此形式
</code></pre>
<p><code>--chown</code>仅支持用户构建linux容器的dockerfile<br>
&lt;src&gt;：要复制的源文件或目录，支持使用通配符<br>
&lt;dest&gt;：目标路径，即正在创建的 image的文件系统路径；建议为 &lt;dest&gt;使用绝对路径，&lt;dest&gt;绝对路径为镜像中的路径，而不是宿主机的路径。否则， <code>COPY</code>指定则以 <code>WORKDIR</code>为其起始路径</p>
<ul>
<li>文件复制准则
<ol>
<li>&lt;src&gt;必须是build上下文中的路径，即只能放在workshop这个工作目录下，不能是其父目录中的文件</li>
<li>如果&lt;src&gt;是目录，其内部文件或者子目录会被递归复制，但&lt;src&gt;目录自身不会被复制</li>
<li>如果指定了多个&lt;src&gt;，或在&lt;src&gt;中使用了通配符，则&lt;dest&gt;必须是一个目录，且&lt;dest&gt;目录必须以<code>/</code>结尾</li>
<li>如果&lt;dest&gt;事先不存在，它将会被自动创建，这包括其父目录路径<br>
例：</li>
</ol>
</li>
</ul>
<pre><code>
[root@node1 ~]# mkdir img1/
[root@node1 ~]# cd img1/
[root@node1 img1]# ls
[root@node1 img1]# vim index.html
&lt;h1&gt;twfr.github.io &lt;/h1&gt;
[root@node1 img1]# vim Dockerfile
# Description: test image
FROM busybox:latest
MAINTAINER &quot;tanxin &lt;lovegood.xin@gmail.com&gt;&quot;
COPY index.html /data/web/html/
</code></pre>
<h3 id="add">ADD</h3>
<p>两种形式：</p>
<pre><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
</code></pre>
<p><code>ADD</code>指令类似于<code>COPY</code>指令， <code>ADD</code>支持使用 TAR文件和 URL路径</p>
<ul>
<li>文件操作准则，同<code>COPY</code>，另外：
<ol>
<li>如果&lt;src&gt;为URL且&lt;dest&gt;不以/结尾，则&lt;src&gt;指定的文件将被下载并直接被创建为&lt;dest&gt;；如果&lt;dest&gt;以/结尾，则文件名URL指定的文件将被直接下载，并保存为&lt;dest&gt;/&lt;filename&gt;，注意，URL不能是ftp格式的url</li>
<li>如果&lt;src&gt;是一个本地系统上的压缩格式的tar文件，它将被展开为一个目录，其行为类似于“tar -x”命令，然后，通过URL获取到的tar文件将不会自动展开</li>
<li>如果&lt;src&gt;有多个，或其间接或直接使用了通配符，则&lt;dest&gt;必须是一个以/结尾的目录路径；如果&lt;dest&gt;不以<code>/</code>结尾，则其被视作一个普通文件，&lt;src&gt;的内容将被直接写入到&lt;dest&gt;</li>
</ol>
</li>
</ul>
<h4 id="copy与add的区别">COPY与ADD的区别</h4>
<p><code>ADD</code>支持使用 TAR文件和 URL路径,支持将tar格式的压缩文件解压到指定的目录</p>
<h3 id=""></h3>

            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://twFR.github.io/post/k8s-summary/">
              <h3 class="post-title">
                 k8s summary
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'db306bd8ac595ee09a0e',
    clientSecret: '7e169f0897298c132e7c038d4d53e8fece891efb',
    repo: 'twFR.github.io',
    owner: 'twFR',
    admin: ['twFR'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  真有意思 绝无可能
不要慌 问题不大☘
 | 
  <a class="rss" href="https://twFR.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
