<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>golang summary | 🌟谭先生✨</title>
<link rel="shortcut icon" href="https://twFR.github.io/favicon.ico?v=1610520130636">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://twFR.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://twFR.github.io">
  <img class="avatar" src="https://twFR.github.io/images/avatar.png?v=1610520130636" alt="">
  </a>
  <h1 class="site-title">
    🌟谭先生✨
  </h1>
  <p class="site-description">
    敲不出代码的程序猿的🏠
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
        <a href="https://www.facebook.com/xin.tan.106902" target="_blank">
          <i class="fab fa-facebook"></i>
        </a>
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              golang summary
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-05-26 ·
              </time>
              
                <a href="https://twFR.github.io/tag/Z7--HtZrc/" class="post-tag">
                  # golang
                </a>
              
            </div>
            
            <div class="post-content">
              <h2 id="数组">数组</h2>
<ul>
<li>数组变量即表示整个数组，是一个完整的值。当i个数组变量<font color=red ><strong>被赋值</strong></font> 或者<font color=red ><strong>被传递</strong></font>的时候，实际上会复制整个数组。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组</li>
<li>数组的定义方式：<pre><code>var a [3]int                    // 定义长度为3的int型数组, 元素全部为0
var b = [...]int{1, 2, 3}       // 定义长度为3的int型数组, 元素为 1, 2, 3
var c = [...]int{2: 3, 1: 2}    // 定义长度为3的int型数组, 元素为 0, 2, 3
var d = [...]int{1, 2, 4: 5, 6} // 定义长度为6的int型数组, 元素为 1, 2, 0, 0, 5, 6
</code></pre>
</li>
</ul>
<h2 id="字符串">字符串</h2>
<ul>
<li>Go字符串底层结构 <code>reflect.StringHeader</code>:<pre><code>type StringHeader struct {
    Data uintptr
    Len   int
}
</code></pre>
字符串结构有两个信息构成：第一个是字符串指向的底层字节数组，第二个是字符串的字节长度。字符串   其实是一个结构体。因此字符串的赋值操作也就是reflect.StringHeader结构体的复制过程，并不会涉   及底层字节数组的复制</li>
<li>字符串虽然不是切片，但是支持切片操作，因为字符串是只读的，相同的字符串面值常量通常对应同一个字符串常量</li>
</ul>
<h2 id="切片">切片</h2>
<ul>
<li>
<p>Go切片的底层结构，<code>reflect.SliceHeader</code>:</p>
<pre><code>type SliceHeader struct {
  Data uintptr
  Len  int
  Cap  int
}
</code></pre>
</li>
<li>
<p>切片的定义方式</p>
<pre><code>var (
    a []int               // nil切片, 和 nil 相等, 一般用来表示一个不存在的切片
    b = []int{}           // 空切片, 和 nil 不相等, 一般用来表示一个空的集合
    c = []int{1, 2, 3}    // 有3个元素的切片, len和cap都为3
    d = c[:2]             // 有2个元素的切片, len为2, cap为3
    e = c[0:2:cap(c)]     // 有2个元素的切片, len为2, cap为3
    f = c[:0]             // 有0个元素的切片, len为0, cap为3
    g = make([]int, 3)    // 有3个元素的切片, len和cap都为3
    h = make([]int, 2, 3) // 有2个元素的切片, len为2, cap为3
    i = make([]int, 0, 3) // 有0个元素的切片, len为0, cap为3
)
</code></pre>
</li>
<li>
<p>添加切片元素</p>
<p>内置的泛型函数append可以在切片的尾部追加N个元素：</p>
<pre><code>var a []int
a = append(a, 1)               // 追加1个元素
a = append(a, 1, 2, 3)         // 追加多个元素, 手写解包方式
a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包
</code></pre>
<p>不过要注意的是，在容量不足的情况下，append的操作会导致重新分配内存，可能导致巨大的内存分配和   复制数据代价。即使容量足够，依然需要用append函数的返回值来更新切片本身，因为新切片的长度已经   发生了变化。</p>
<p>除了在切片的尾部追加，我们还可以在切片的开头添加元素：</p>
<pre><code>var a = []int{1,2,3}
a = append([]int{0}, a...)        // 在开头添加1个元素
a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
</code></pre>
<p>在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制1次。因此，从切片的开头添加元    素的性能一般要比从尾部追加元素的性能差很多。</p>
<p>由于append函数返回新的切片，也就是它支持链式操作。我们可以将多个append操作组合起来，实现在    切片中间插入元素：</p>
<pre><code>var a []int
a = append(a[:i], append([]int{x}, a[i:]...)...)     // 在第i个位置插入x
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
</code></pre>
<p>每个添加操作中的第二个append调用都会创建一个临时切片，并将a[i:]的内容复制到新创建的切片中,<br>
然后将临时创建的切片再追加到a[:i]。</p>
<p>可以用copy和append组合可以避免创建中间的临时切片，同样是完成添加元素的操作：</p>
<pre><code>a = append(a, 0)     // 切片扩展1个空间
copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置
a[i] = x             // 设置新添加的元素
</code></pre>
<p>第一句append用于扩展切片的长度，为要插入的元素留出空间。第二句copy操作将要插入位置开始之后    的元素向后挪动一个位置。第三句真实地将新添加的元素赋值到对应的位置。操作语句虽然冗长了一点，   但是相比前面的方法，可以减少中间创建的临时切片。</p>
<p>用copy和append组合也可以实现在中间位置插入多个元素(也就是插入一个切片):</p>
<pre><code>a = append(a, x...)       // 为x切片扩展足够的空间
copy(a[i+len(x):], a[i:]) // a[i:]向后移动len(x)个位置
copy(a[i:], x)            // 复制新添加的切片
</code></pre>
<p>稍显不足的是，在第一句扩展切片容量的时候，扩展空间部分的元素复制是没有必要的。没有专门的内置   函数用于扩展切片的容量，append本质是用于追加元素而不是扩展容量，扩展切片容量只是append的一    个副作用。</p>
</li>
<li>
<p>删除切片元素</p>
<p>根据要删除元素的位置有三种情况：从开头位置删除，从中间位置删除，从尾部删除。其中删除切片尾部   的元素最快：</p>
<pre><code>a = []int{1, 2, 3}
a = a[:len(a)-1]   // 删除尾部1个元素
a = a[:len(a)-N]   // 删除尾部N个元素
</code></pre>
<p>删除开头的元素可以直接移动数据指针：</p>
<pre><code>a = []int{1, 2, 3}
a = a[1:] // 删除开头1个元素
a = a[N:] // 删除开头N个元素
</code></pre>
<p>删除开头的元素也可以不移动数据指针，但是将后面的数据向开头移动。可以用append原地完成（所谓原   地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：</p>
<pre><code>a = []int{1, 2, 3}
a = append(a[:0], a[1:]...) // 删除开头1个元素
a = append(a[:0], a[N:]...) // 删除开头N个元素
</code></pre>
<blockquote>
<p>假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，<br>
从而导致不能及时被自动垃圾回收器回收（这要依赖回收器的实现方式）：</p>
<pre><code>var a []*int{ ... }
a = a[:len(a)-1]    // 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍
</code></pre>
<p>保险的方式是先将需要自动内存回收的元素设置为nil，保证自动回收器可以发现需要回收的对象，然后再进行切片的删除操作：</p>
<pre><code>var a []*int{ ... }
a[len(a)-1] = nil // GC回收最后一个元素内存
a = a[:len(a)-1]  // 从切片删除最后一个元素
</code></pre>
<p>当然，如果切片存在的周期很短的话，可以不用刻意处理这个问题。因为如果切片本身已经可以被GC回收的话，切片对应的每个元素自然也就是可以被回收的了。</p>
</blockquote>
<p>也可以用copy完成删除开头的元素：</p>
<pre><code>a = []int{1, 2, 3}
a = a[:copy(a, a[1:])] // 删除开头1个元素
a = a[:copy(a, a[N:])] // 删除开头N个元素
</code></pre>
<p>对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用append或copy原地完成：</p>
<pre><code>a = []int{1, 2, 3, ...}

a = append(a[:i], a[i+1:]...) // 删除中间1个元素
a = append(a[:i], a[i+N:]...) // 删除中间N个元素

a = a[:i+copy(a[i:], a[i+1:])]  // 删除中间1个元素
a = a[:i+copy(a[i:], a[i+N:])]  // 删除中间N个元素
</code></pre>
<p>删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况。</p>
</li>
</ul>
<h2 id="函数">函数</h2>
<ul>
<li>
<p>当可变参数是一个空接口类型时，调用者是否解包可变参数会导致不同的结果：</p>
<pre><code>func main() {
   var a = []interface{}{123, &quot;abc&quot;}

   Print(a...) // [123 abc]
   Print(a)    // [[123 abc]]
}

func Print(a ...interface{}) {
   fmt.Println(a...)
}
</code></pre>
<p>第一个Print调用时传入的参数是a...，等价于直接调用Print(123, &quot;abc&quot;)。第二个Print调用传入的   是未解包的a，等价于直接调用Print([]interface{}{123, &quot;abc&quot;})</p>
</li>
<li>
<p>defer语句延迟执行了一个匿名函数，因为这个匿名函数捕获了外部函数的局部变量v，这种函数我们一般叫闭包。闭包对捕获的外部变量并不是传值方式访问，而是以<font color=red><strong>引用</strong></font>的方式访问</p>
<p>闭包的这种引用方式访问外部变量的行为可能会导致一些隐含的问题：</p>
<pre><code>func main() {
    for i := 0; i &lt; 3; i++ {
        defer func(){ println(i) } ()
    }
}
// Output:
// 3
// 3
// 3
</code></pre>
<p>因为是闭包，在for迭代语句中，每个defer语句延迟执行的函数引用的都是同一个i迭代变量，在循环结束后这个变量的值为3，因此最终输出的都是3。</p>
<p>修复的思路是在每轮迭代中为每个defer函数生成独有的变量。可以用下面两种方式：</p>
<pre><code>func main() {
    for i := 0; i &lt; 3; i++ {
        i := i // 定义一个循环体内局部变量i
        defer func(){ println(i) } () //因为是引用，所以这里的局部变量i每次循环地址均不同
    }
}

func main() {
    for i := 0; i &lt; 3; i++ {
        // 通过函数传入i
        // defer 语句会马上对调用参数求值
        defer func(i int){ println(i) } (i)
    }
}
</code></pre>
<p>。。。。持续更新</p>
</li>
</ul>

            </div>
          </article>
        </div>

        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'db306bd8ac595ee09a0e',
    clientSecret: '7e169f0897298c132e7c038d4d53e8fece891efb',
    repo: 'twFR.github.io',
    owner: 'twFR',
    admin: ['twFR'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  真有意思 绝无可能
不要慌 问题不大☘
 | 
  <a class="rss" href="https://twFR.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
