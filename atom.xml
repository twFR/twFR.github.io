<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://twFR.github.io</id>
    <title>🌟谭先生✨</title>
    <updated>2021-01-14T14:25:08.759Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://twFR.github.io"/>
    <link rel="self" href="https://twFR.github.io/atom.xml"/>
    <subtitle>敲不出代码的程序猿的🏠</subtitle>
    <logo>https://twFR.github.io/images/avatar.png</logo>
    <icon>https://twFR.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 🌟谭先生✨</rights>
    <entry>
        <title type="html"><![CDATA[prime filter ]]></title>
        <id>https://twFR.github.io/post/prime-fliter/</id>
        <link href="https://twFR.github.io/post/prime-fliter/">
        </link>
        <updated>2020-06-02T07:01:03.000Z</updated>
        <content type="html"><![CDATA[<p>使用并发来做一个素数筛</p>
<pre><code>package main

import &quot;fmt&quot;

func main() {
	ch :=GenerateNatural()
	for i:=0;i&lt;100;i++{
		prime := &lt;-ch                              // 第一个一定是素数
		fmt.Printf(&quot;%v: %v\n&quot;, i+1, prime)
		ch = primeFliter(ch,prime)
	}
}

// 生成一个自然数列
func GenerateNatural() chan int {
	ch := make(chan int)
	go func() {
		for i := 2; ; i++ {
			ch &lt;- i
		}
	}()
	return ch
}

// 根据prime过滤，过滤后的第一个一定是素数
func primeFliter(in &lt;- chan int,prime int) chan int{
	out := make(chan int)
	go func() {
		for {
			if i:=&lt;-in;i%prime!=0{
				out &lt;- i
			}
		}
	}()
	return out
}
</code></pre>
<p>GenerateNatural和PrimeFilter函数内部都启动了新的Goroutine，当main函数不再使用管道时后台Goroutine有泄漏的风险。可以通过context包来避免这个问题，下面是改进的素数筛实现：</p>
<pre><code>package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
)

func GenerateNatural(ctx context.Context) chan int {
	ch := make(chan int)
	go func() {
		for i := 2; ; i++ {
			select {
			case &lt;-ctx.Done():
				return
			case ch &lt;- i:
			}
		}
	}()
	return ch
}

func primeFilter(ctx context.Context, in &lt;-chan int, prime int) chan int {
	out := make(chan int)
	go func() {
		for {
			if i := &lt;-in; i%prime != 0 {
				select {
				case &lt;-ctx.Done():
					return
				case out &lt;- i:
				}
			}
		}
	}()
	return out
}

func main() {

	ctx, cancel := context.WithCancel(context.Background())
	ch := GenerateNatural(ctx)
	for i := 0; i &lt; 1000; i++ {
		prime := &lt;-ch
		fmt.Printf(&quot;%v: %v\n&quot;, i+1, prime)
		ch = primeFilter(ctx, ch, prime)
	}

	cancel()   // main函数完成时，调用cancel(),通知后台goroutine退出，即ctx.Done收到信号
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[golang unsafe package]]></title>
        <id>https://twFR.github.io/post/golang-unsafe-package/</id>
        <link href="https://twFR.github.io/post/golang-unsafe-package/">
        </link>
        <updated>2020-05-08T06:27:11.000Z</updated>
        <content type="html"><![CDATA[<p>使用unsafe.Pointer来取切片的属性</p>
<pre><code>func testPointer() {
	s := make([]int, 9, 20)
	s = append(s, 2)
	len := *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + uintptr(8)))
	cap := *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + uintptr(16)))

	dataPointer := *(*int)(unsafe.Pointer(&amp;s))
	data1 := *(*int)(unsafe.Pointer(uintptr(dataPointer)))

	fmt.Printf(&quot;len: %d cap:%d \n&quot;, len, cap)
	fmt.Printf(&quot;dataPointer: %d  data1:%d \n&quot;, dataPointer, data1)

	i := 0
	for {
		if i &gt;= len {
			break
		}
		fmt.Printf(&quot;data%d:%d \n&quot;, i, *(*int)(unsafe.Pointer(uintptr(dataPointer) + uintptr(8*i))))
		i++
	}
}
</code></pre>
<p>unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。</p>
<p>unsafe 包定义了 Pointer 和三个函数：</p>
<p>通过三个函数可以获取变量的大小(Sizeof)、偏移(Offsetof)、对齐(Alignof)等信息。</p>
<p>uintptr 可以和 unsafe.Pointer 进行相互转换，uintptr 可以进行数学运算。这样，通过 uintptr 和 unsafe.Pointer 的结合就解决了 Go 指针不能进行数学运算的限制。</p>
<p>通过 unsafe 相关函数，可以获取结构体私有成员的地址，进而对其做进一步的读写操作，突破 Go 的类型安全限制。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ k8s summary]]></title>
        <id>https://twFR.github.io/post/k8s-summary/</id>
        <link href="https://twFR.github.io/post/k8s-summary/">
        </link>
        <updated>2020-03-14T13:57:21.000Z</updated>
        <content type="html"><![CDATA[<p>Kubernetes 提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足扩展要求、故障转移、部署模式等，提供以下服务</p>
<ul>
<li>服务发现和负载均衡</li>
<li>存储编排</li>
<li>自动部署和回滚</li>
<li>自动完成装箱计算</li>
<li>自我修复</li>
<li>密钥与配置管理</li>
</ul>
<h2 id="组件">组件</h2>
<ul>
<li>
<p>控制面组件（管理面）</p>
<ol>
<li>kube-apiserver  服务器，提供API</li>
<li>kube- controler-manager
<ul>
<li>node controller：负责节点出现故障时进行通知和响应</li>
<li>replication controller：负责为系统中每个副本控制器对象维护正确数量的pod</li>
<li>endpoint controller：填充endpoints对象（即加入service与pod）</li>
<li>service account&amp; token contolers：为新的命名空间传家默认账户和API访问令牌</li>
</ul>
</li>
<li>kube-scheduler 监视新创建  未指定node的pods，选择node让pod运行</li>
<li>etcd  保存集群数据</li>
</ol>
</li>
<li>
<p>Node组件（数据面）</p>
<ol>
<li>kubelet  每个node上的代理。保证containers都运行在pod中。接收一组提供给kubelet的PodSpecs，确保PodSpecs描述的容器处于运行状态且健康。不会管理不是kubernets创建的容器</li>
<li>kube-proxy 每个节点上运行的网络代理，维护节点上的网络规则</li>
</ol>
</li>
<li>
<p>Container Runtime 负责运行容器的软件（docker containers CRI-O）</p>
</li>
<li>
<p>插件（Addons）</p>
<p>插件使用 Kubernetes 资源（<a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>、 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a>等）实现集群功能。如DNS，Dashboard</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[k8s Installation and deployment]]></title>
        <id>https://twFR.github.io/post/k8s-installation-and-deployment/</id>
        <link href="https://twFR.github.io/post/k8s-installation-and-deployment/">
        </link>
        <updated>2019-11-19T16:30:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="准备">准备</h2>
<ul>
<li>Macos/windows系统电脑</li>
<li>vmware虚拟机</li>
<li><a href="http://old-releases.ubuntu.com/releases/18.10/ubuntu-18.10-live-server-amd64.iso">Ubuntu18.10</a></li>
<li><a href="http://m6.pc6.com/xuh6/scrt854.zip">secureCRT</a>（用来管理虚拟机的，比直接用vmware好用多了）</li>
<li><a href="https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/docker-ce_18.06.1~ce~3-0~ubuntu_amd64.deb">docker-ce 18.06</a></li>
</ul>
<p>由于我有你们懂得的东西，可以去国外下载对应的镜像组件等，还是比较方便，如果是没有的话，可能还得配置网络源等东西会比较麻烦</p>
<h2 id="安装ubuntu">安装ubuntu</h2>
<p>我是用的mac装的vnware，在虚拟机里面装的ubuntu，还是蛮简单的，注意的是需要至少给虚拟机cpu分配两核，k8s至少要两核才能安装</p>
<h4 id="安装需要的软件">安装需要的软件</h4>
<p>安装一些基础工具</p>
<blockquote>
<p>sudo apt-get update &amp;&amp; apt-get install -y curl telnet wget man \</p>
</blockquote>
<blockquote>
<p>apt-transport-https ca-certificates software-properties-common vim</p>
</blockquote>
<h2 id="安装docker">安装docker</h2>
<ul>
<li>
<p>下载docker18.06的离线安装包  [18.06]</p>
</li>
<li>
<p>scp到自己的虚拟机上面去</p>
<p>先查看自己虚拟机的ip地址：ifconfig<br>
然后 scp docker-ce_18.06.1_ce_3-0_ubuntu_amd64.deb tan@172.16.234.132:/home/tan/package</p>
</li>
</ul>
<p>搞定</p>
<ul>
<li>
<p>离线安装虚拟机</p>
<blockquote>
<p>sudo dpkg -i  docker-ce_18.06.1_ce_3-0_ubuntu_amd64.deb</p>
</blockquote>
<p>我安装遇到了错误 提示我依赖缺失 然后我就安装依赖</p>
<blockquote>
<p>sudo apt-get install -y libltd17</p>
</blockquote>
<p>然后又提示我找不到包，应该就是源文件的问题，更新下源文件</p>
<blockquote>
<p>#仅检查，不更新</p>
<p>sudo apt update</p>
<p>#更新已安装的软件包</p>
<p>sudo apt upsade</p>
</blockquote>
<p>解决之后重新安装docker，搞定</p>
</li>
<li>
<p>允许开机启动docker</p>
<blockquote>
<p>sudo systemctl enable docker</p>
<p>sudo systemctl start docker</p>
</blockquote>
</li>
<li>
<p>启动一个精简的操作系统容器测试</p>
<blockquote>
<p>sudo docker run -ti alpine:latest sh</p>
</blockquote>
</li>
<li>
<p>将当前的普通用户添加到当前的docker用户组里面去</p>
<blockquote>
<p>sudo groupadd docker</p>
<p>sudo usermod -aG docker $USER</p>
</blockquote>
</li>
</ul>
<h2 id="kubernetes安装">kubernetes安装</h2>
<ul>
<li>
<p>免费的阿里云镜像加速器</p>
<p>https://ozcouvlb.mirror.aliyuncs.com</p>
</li>
<li>
<p>配置国内镜像加速器</p>
<blockquote>
<p>vim /etc/docker/daemon.json</p>
<p>#文件里的内容如下：</p>
<p># {</p>
<p>#	&quot;registry-mirrors&quot;:  [https://ozcouvlb.mirror.aliyuncs.com]</p>
<p>#}</p>
</blockquote>
</li>
<li>
<p>重启docker服务</p>
<blockquote>
<p>sudo systemctl daemon-reload</p>
<p>sudo systemctl restart docker</p>
</blockquote>
</li>
<li>
<p>配置并安装k8s源</p>
</li>
<li>
<p>创建配置文件</p>
<blockquote>
<p>sudo vim /etc/apt/sources.list.d/kubernetes.list</p>
<p>#添加以下内容</p>
<p>#deb https://mirrors.ustc.edu.cn/kubernetes/apt kubernets-xenial main</p>
<p>sudo chmod 640 /etc/apt/sources.list.d/kubernetes.list</p>
</blockquote>
</li>
<li>
<p>执行如下命令更新操作系统源</p>
</li>
</ul>
<pre><code>&gt; sudo apt update
</code></pre>
<ul>
<li>
<p>有可能遇到的问题 NO_PUBKEY,解决方法如下：</p>
<blockquote>
<p>#添加认证 一定要用自己的账户执行，不能用root</p>
</blockquote>
<blockquote>
<p>sudo gpg --keyserver keyserver.ubuntu.com --recv-keys BA07F4FB(回显NO_PUBKEY的后8位)</p>
<p>sudo gpg --export --armor BA07F4FB</p>
<p>#将回显的key保存到一个文件里面</p>
<p>vim pubkey</p>
<p>#将ley添加到本地的truested数据库中</p>
<p>sudo apt-key add pubkey</p>
</blockquote>
</li>
<li>
<p>解决后再次更新，完美搞定</p>
</li>
<li>
<p>禁止基础设施</p>
<ul>
<li>关闭防火墙（容器之间通讯不需要这些限制,话说我之前用win一直也都是关闭的）</li>
</ul>
<blockquote>
<p>sudo ufw disable</p>
</blockquote>
<ul>
<li>
<p>关闭swap(k8s不希望使用swap)</p>
<blockquote>
<p>sudo swapoff -a</p>
<p>永久关闭</p>
<p>sudo sed -i 's/.*swap.*/#$/' /etc/fstab</p>
</blockquote>
</li>
<li>
<p>禁止selinux（ubuntu默认安装的安全组件）</p>
<blockquote>
<p>#安装操控selinux的组件</p>
<p>sudo apt install -y selinux-utils</p>
<p>#禁止selinux</p>
<p>setenforce 0</p>
<p>#重启</p>
<p>shutdown -r now</p>
<p>#查看是否关闭</p>
<p>sudo getenforce</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>k8s系统网络配置</p>
<ol>
<li>配置内核参数，将桥接的IPv4流量传递到iptables的链</li>
</ol>
<p>创建配置文件</p>
<blockquote>
<p>sudo vim /etc/sysctl.d/k8s.conf</p>
</blockquote>
<p>添加如下内容：</p>
<blockquote>
<p>net.bridge.bridge-nf-call-ip6tables = 1</p>
<p>net.bridge.bridge-nf-call-iptables = 1</p>
<p>vm.swappiness = 0</p>
</blockquote>
<ol start="2">
<li>
<p>使配置文件生效</p>
<blockquote>
<p>sudo modprobe br_netfilter</p>
</blockquote>
<blockquote>
<p>sudo sysctl -p /etc/sysctl.d/k8s.conf</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>安装k8s</p>
<blockquote>
<p>sudo apt update &amp;&amp; apt-get install -y kubelet=1.13.1-00 kubernetes-cni=0.6.0-00 kubeadm=1.13.1-00 kubectl=1.13.1-00</p>
</blockquote>
<ul>
<li>kubelet 永久的后端服务</li>
<li>kubectl 客户端进程，用户和开发者使用kubectl可以运维维护k8s</li>
<li>kubeadm 也是客户端进程，权限很高，相当于管理员，用的很少</li>
</ul>
</li>
<li>
<p>设置开机自启动</p>
<blockquote>
<p>sudo systemctl enable kubelet &amp;&amp; systemctl start kubelet</p>
<p>sudo shutdown -r now</p>
</blockquote>
</li>
<li>
<p>验证k8s</p>
<blockquote>
<p>kubectl get nodes</p>
<p>kubectl version</p>
</blockquote>
</li>
</ul>
<h2 id="创建多节点">创建多节点</h2>
<ul>
<li>
<p>将已经搭建好的环境的虚拟机复制两份出来，搭建一个三节点的集群</p>
<p>将已经搭建好开发环境的虚拟机关机，然后创建完整克隆</p>
</li>
<li>
<p>之后再用ifconfig命令查看新节点的ip，用secureCRT登录节点</p>
</li>
<li>
<p>给node配置hostname</p>
<blockquote>
<p>su</p>
<p>vim /etc/hostname</p>
<p>#分别改为master/node1/node2</p>
</blockquote>
</li>
<li>
<p>配置ip地址</p>
<blockquote>
<p>vim /etc/netplan/50-cloud-init.yaml</p>
</blockquote>
</li>
</ul>
<p>network:</p>
<p>​	 ethernets:</p>
<p>​			ens33:</p>
<p>​					addresses: [172.16.234.134/24]</p>
<p>​					dhcp4: false</p>
<p>​					gateway4: 172.16.234.2</p>
<p>​					nameservers:</p>
<p>​									addresses: [172.16.234.2]</p>
<p>​					optional: true</p>
<p>​			version: 2</p>
<p>按照自己节点的ip配置，也可以自己定为连续的ip，方便操作，dhcp改成false防止每次重启ip变掉</p>
<p>​	&gt; netplan apply</p>
<p>使配置生效</p>
<ul>
<li>
<p>修改hosts文件</p>
<blockquote>
<p>vim /etc/hosts</p>
<p>#输入以下内容</p>
<p>#172.16.234.132 master</p>
<p>#172.16.234.133 node1</p>
<p>#172.16.234.134 node2</p>
</blockquote>
</li>
</ul>
<p>三个节点均需要配置,通过ping来检验是否配置成功</p>
<h2 id="部署k8s集群">部署k8s集群</h2>
<ul>
<li>
<p>---------<font color=red><strong>master节点上配置</strong></font> --------</p>
</li>
<li>
<p>创建k8s的管理工具kubeadm对应的配置文件，候选操作在/home/itcast/working/ 目录下</p>
</li>
<li>
<p>使用kubeadm配置文件，通过在配置文件中指定docker镜像地址部署</p>
<p>生成配置文件</p>
<blockquote>
<p>kubeadm config print init-defaults ClusterConfiguration &gt; kubeadm.conf</p>
</blockquote>
</li>
<li>
<p>修改配置文件里面的下面项</p>
<blockquote>
<p>vim kubeadm.conf</p>
<p>#修改k8s版本号为v1.13.1</p>
<p>kubernetesVersion: v1.13.1</p>
<p>#修改hostname为master</p>
<p>name: master</p>
<p>#修改kubeadm.conf中的API服务器地址</p>
<p>localAPIEndpoint:</p>
<p>​    advertiseAddress: 172.16.234.132    # master的IP</p>
<p>​    bindPort：6443</p>
<p>#配置子网网络</p>
<p>networking:</p>
<p>​    dnsDomian: cluster.local</p>
<p>​    podSubnet: &quot;10.244.0.0/16&quot;         #  k8s内部pod网络,官方推荐</p>
<p>​    servicesSubnet: 10.96.0.0/12    # k8s服务网络,官方推荐</p>
<p>scheduler: {}</p>
</blockquote>
</li>
<li>
<p>拉取k8s必备的模块镜像</p>
<blockquote>
<p>#查看需要哪些镜像文件需要拉取</p>
<p>kubeadm config images list --config kubeadm.conf</p>
<p>#k8s.gcr.io/kube-apiserver:v1.13.1.                   对外端口，提供入口让外部访问集群<br>
#k8s.gcr.io/kube-controller-manager:v1.13.1     内部管理器<br>
#k8s.gcr.io/kube-scheduler:v1.13.1                   内部任务调度器<br>
#k8s.gcr.io/kube-proxy:v1.13.1                         负载均衡<br>
#k8s.gcr.io/pause:3.1                                     业务容器共享Pause容器的网络栈和Volume挂载卷，因此他们之间通信和数据交换更为高效<br>
#k8s.gcr.io/etcd:3.2.24                                  数据一致性<br>
#k8s.gcr.io/coredns:1.2.6</p>
<p>#拉取全部当前版本k8s关联的镜像</p>
<p>kubeadm config images pull --config ./kubeadm.conf</p>
<p>#如果无法下载，只能去docker.io仓库手动拉镜像然后改tag（或者registry.cn-hangzhou.aliyuncs.com/google_containers）</p>
<p>docker pull mirrorgooglecontainers/kube-apiserver:v1.13.1</p>
<p>docker tag mirrorgooglecontainers/kube-apiserver:v1.13.1 k8s.gcr.io/kube-apiserver:v1.13.1 #打tag，和需要的镜像名保持一致</p>
<p>docker rmi mirrorgooglecontainers/kube-apiserver:v1.13.1    #删除掉多余的镜像</p>
<p>#其他所有镜像类似,k8s.gcr.io/coredns:1.2.6特例</p>
<p>docker pull coredns/coredns:1.1.3</p>
<p>root@tan:/home/tan/package# docker images<br>
REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE<br>
k8s.gcr.io/kube-proxy                v1.13.1             fdb321fd30a0        11 months ago       80.2MB<br>
k8s.gcr.io/kube-apiserver            v1.13.1             40a63db91ef8        11 months ago       181MB<br>
k8s.gcr.io/kube-controller-manager   v1.13.1             26e6f1db2a52        11 months ago       146MB<br>
k8s.gcr.io/kube-scheduler            v1.13.1             ab81d7360408        11 months ago       79.6MB<br>
k8s.gcr.io/etcd                      3.2.24              3cab8e1b9802        14 months ago       220MB<br>
k8s.gcr.io/coredns                   1.2.6               b3b94275d97c        18 months ago       45.6MB<br>
k8s.gcr.io/pause                     3.1                 da86e6ba6ca1        23 months ago       742kB</p>
</blockquote>
</li>
<li>
<p>初始化k8s环境</p>
<blockquote>
<p>sudo kubeadm init --config ./kubeadm.conf</p>
</blockquote>
</li>
</ul>
<p>回显如下：</p>
<pre><code>	 &gt; Your Kubernetes master has initialized successfully!
	 &gt;
	 &gt; To start using your cluster, you need to run the following as a regular user:
	 &gt;
	 &gt; ​    mkdir -p $HOME/.kube
	 &gt;
	 &gt; ​	sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
	 &gt;
	 &gt; ​	sudo chown $(id -u):$(id -g) $HOME/.kube/config
	 &gt;
	 &gt; You should now deploy a pod network to the cluster.
	 &gt; Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
	 &gt;   https://kubernetes.io/docs/concepts/cluster-administration/addons/
	 &gt;
	 &gt; You can now join any number of machines by running the following on each node
	 &gt; as root:
	 &gt;
	 &gt;   kubeadm join 172.16.234.132:6443 --token abcdef.0123456789abcdef --discovery-token-ca-cert-hash sha256:ebc50ff8588c35917f9c6f84f2bd8048352b82bfb9ef06cf5b63934cb9862f49
</code></pre>
<p>根据提示，做如下操作</p>
<blockquote>
<p>#master节点基本文件夹配置</p>
</blockquote>
<blockquote>
<p>mkdir -p $HOME/.kube</p>
<p>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</p>
<p>sudo chown <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mi>d</mi><mo>−</mo><mi>u</mi><mo>)</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">(id -u):</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>(id -g) $HOME/.kube/config</p>
</blockquote>
<p>同时，如果node节点想要加入master集群，需要执行以下命令</p>
<blockquote>
<p>kubeadm join 172.16.234.132:6443 --token abcdef.0123456789abcdef --discovery-token-ca-cert-hash sha256:ebc50ff8588c35917f9c6f84f2bd8048352b82bfb9ef06cf5b63934cb9862f49</p>
</blockquote>
<ul>
<li>
<p>启动k8s</p>
<blockquote>
<p>sudo systemctl enable kubelet</p>
<p>sudo systemctl start kubelet</p>
</blockquote>
</li>
<li>
<p>验证k8s启动结果</p>
<blockquote>
<p>kubectl get node</p>
</blockquote>
</li>
</ul>
<p>如果有问题，可以参考这个 <a href="https://stackoverflow.com/questions/52720380/kubernetes-api-server-is-not-starting-on-a-single-kubeadm-cluster">拉取最新版本</a>然后重新来一遍，我就是这个花了一下午（微笑脸）</p>
<p>未完待续。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fibobacci]]></title>
        <id>https://twFR.github.io/post/fibobacci/</id>
        <link href="https://twFR.github.io/post/fibobacci/">
        </link>
        <updated>2019-11-18T15:49:09.000Z</updated>
        <content type="html"><![CDATA[<p>今天简单做一个题，这个点了，太累了，打卡滴</p>
<h2 id="需求">需求</h2>
<p>给一个数N，看能通过多少步N+1或者N-1使它成为fibobacci数<br>
0&lt; N &lt;1000000<br>
fibobacci都清楚 0 1 1 2 3 5 8 13 ... 不赘述</p>
<h2 id="示例">示例</h2>
<p>输入：</p>
<blockquote>
<p>5<br>
15</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>0<br>
2</p>
</blockquote>
<h2 id="解题思路">解题思路</h2>
<p>这个就很简单，不用说了<br>
看我极简代码风格，哈哈哈😂</p>
<h2 id="极简代码">极简代码</h2>
<pre><code>package main

import &quot;fmt&quot;

func main() {
	var number int
	for {
		if num, err := fmt.Scanf(&quot;%d&quot;, &amp;number); num != 1 || err != nil {
			return
		}
		begin, next := 0, 1
		for begin+next &lt; number {
			begin, next = next, begin+next
		}
		if number-next &lt; begin+next-number {
			fmt.Println(number - next)
		} else {
			fmt.Println(begin + next - number)
		}
	}
}

</code></pre>
<p>当然不推荐，容易被打死</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[binary search]]></title>
        <id>https://twFR.github.io/post/binary-search/</id>
        <link href="https://twFR.github.io/post/binary-search/">
        </link>
        <updated>2019-11-17T12:43:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="需求">需求</h2>
<p>小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天的一半，但是他又不想在父母回来之前把巧克力吃完，请问他<font color=red>第</font>一天<font color=red>最多</font>能吃多少块蛋糕<br>
N&lt;=50000,N&lt;M&lt;100000</p>
<h2 id="示例">示例</h2>
<p>输入：</p>
<blockquote>
<p>3 7<br>
4 7</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>4<br>
3</p>
</blockquote>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>本题可以想成，我从1～M块巧克力中选出一块来，这块巧克力就是我第一天最多能吃的巧克力</li>
<li>那这个选出来的有什么条件需要满足呢：要满足我选出来的这个是第一天最多能吃的，那么就是最后几天都要吃最少的，但又要满足不少于前一天的一半，所以就是刚好吃前一天的一半。注意的是，这里要吃就是一整块，不存在是吃几分之一块，强迫症很舒服</li>
<li>那就是我用二分查找法去选一个巧克力数出来，去看是否满足条件</li>
<li>这个条件呢就是你每天吃的加起来刚好或者说小于你的总巧克力数，不能饿死嘛，保证每天都有吃的</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math&quot;
	&quot;os&quot;
)

// 出差天数
var N int

// 巧克力个数
var M int

func main() {
	for {
		num, err := fmt.Scanf(&quot;%d %d&quot;, &amp;N, &amp;M)
		if num != 2 || err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		search()
	}
}

// 假如第一天吃n个,计算总共吃了多少个
func sum(n int) (m int) {
	for i := 0; i &lt; N; i++ {
		m =m + n
		n = int(math.Ceil(float64 (n) / 2))
	}
	return m
}

// 二分查找满足的条件
func search() {
	begin := 1
	end := M
	mid := 0
	if N == 1 {
		fmt.Println(M)
		return
	}
	for i := 0; i &lt; M; i++ {

		if begin &gt; end {
			break
		}
		// 向上取整，要吃就要吃一整个
		mid = int(math.Ceil(float64(end+begin) / 2))
		if sum(mid) == M {
			fmt.Println(mid)
			return
		}
		if sum(mid) &lt; M {
			// 取等于是因为防止没有正好吃完的情况，需要取mid的值
			begin = mid
		} else {
			end = mid - 1
		}
	}
	// 这是有剩余巧克力的情况
	fmt.Println(mid)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Insert sort]]></title>
        <id>https://twFR.github.io/post/insert-sort/</id>
        <link href="https://twFR.github.io/post/insert-sort/">
        </link>
        <updated>2019-11-15T15:36:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="需求">需求</h2>
<p>输入n个数字，（第一行数字表示将要输入数字的个数）<br>
按从小到大的顺序排序后一行输出</p>
<h2 id="示例">示例</h2>
<p>输入：</p>
<blockquote>
<p>5<br>
12<br>
45<br>
2<br>
14<br>
1</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>1 2 12 14 45</p>
</blockquote>
<h2 id="解题思路">解题思路</h2>
<p>今天使用插入排序来解决这个问题</p>
<ul>
<li>循环需要排序的数组</li>
<li>从第二个数字开始，和前一个比较，如果比前一个小，就说明这第i个数字n需要重新排序</li>
<li>将这个数字和前面的所有数字比较，当n比第j个数字位置小的时候（j&lt;i），则说明这个j位置就是n需要插入的位置</li>
<li>将j位置到i-1位置的数字全部顺序向后移动一个位置，即将【i-1】赋给【i】，最后将最开始的【i】赋给【j】</li>
<li>循环完数组则排序完毕，over</li>
</ul>
<pre><code>func insertSort(disorderNumber []int) []int {
	for i := 1; i &lt; len(disorderNumber); i++ {
		if disorderNumber[i] &lt; disorderNumber[i-1] {
			for j := 0; j &lt; i; j++ {
				if disorderNumber[j] &gt; disorderNumber[i] {
					// 插入位置
					temp := disorderNumber[i]
					// 将插入位置后面的数到需要插入的数整体后移一位
					for k := i; k &gt; j; k-- {
						disorderNumber[k] = disorderNumber[k-1]
					}
					disorderNumber[j] = temp
				}
				// 如果找到插入位置，则不需要再向后面循环
				break
			}
		}
	}
	return disorderNumber
}
</code></pre>
<h2 id="完整代码">完整代码</h2>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strconv&quot;
)

func main() {
	var num int
	n, err := fmt.Scanf(&quot;%d&quot;, &amp;num)
	if n != 1 || err != nil {
		os.Exit(1)
	}
	disorderNumber := make([]int, num)
	for i := 0; i &lt; num; i++ {
		n, err := fmt.Scanf(&quot;%d&quot;, &amp;disorderNumber[i])
		if n != 1 || err != nil {
			fmt.Println(n,err)
			os.Exit(1)
		}
	}
	orderNumber := insertSort(disorderNumber)
	for i := 0; i &lt; len(orderNumber); i++ {
		fmt.Print(strconv.Itoa(orderNumber[i]) + &quot; &quot;)
	}
}

func insertSort(disorderNumber []int) []int {
	for i := 1; i &lt; len(disorderNumber); i++ {
		if disorderNumber[i] &lt; disorderNumber[i-1] {
			for j := 0; j &lt; i; j++ {
				if disorderNumber[j] &gt; disorderNumber[i] {
					// 插入位置
					temp := disorderNumber[i]
					// 将插入位置后面的数到需要插入的数整体后移一位
					for k := i; k &gt; j; k-- {
						disorderNumber[k] = disorderNumber[k-1]
					}
					disorderNumber[j] = temp
				}
				// 如果找到插入位置，则不需要再向后面循环
				break
			}
		}
	}
	return disorderNumber
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Multiplication by large numbers]]></title>
        <id>https://twFR.github.io/post/multiplication-by-large-numbers/</id>
        <link href="https://twFR.github.io/post/multiplication-by-large-numbers/">
        </link>
        <updated>2019-11-14T14:02:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="需求">需求</h2>
<p>求n的阶乘（0&lt;n&lt;1000）</p>
<h2 id="示例">示例</h2>
<p>输入：</p>
<blockquote>
<p>2<br>
3</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>2<br>
6</p>
</blockquote>
<h2 id="解题思路">解题思路</h2>
<p>普通的数据类型肯定没法承载精确的大数的阶层，所以这实际就是一个大数相乘算法</p>
<ul>
<li>用一个数组来装大数的每一位</li>
<li>用数组的每一个值去乘被乘数</li>
<li>将数组从后往前进位然后留值，因为数字相邻两位相差10的倍数，就以10进1，例如数组最后一位为102，则向前进10，留2</li>
<li>最后顺序打出不换行的数组每个值就是结果，需要注意的是数组的长度</li>
</ul>
<pre><code>func multiplication(largeNumber [1000]int, number int) [1000]int {
	for i := 0; i &lt; len(largeNumber); i++ {
		largeNumber[i] = largeNumber[i] * number
	}
	for i := len(largeNumber) - 1; i &gt; 0; i-- {
		// 进位
		largeNumber[i-1] = largeNumber[i]/10 + largeNumber[i-1]
		// 留值
		largeNumber[i] = largeNumber[i] % 10
	}
	return largeNumber
}
</code></pre>
<h2 id="完整实现">完整实现</h2>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	for {
		var num int
		var largeNumber [1000]int
		n, err := fmt.Scanf(&quot;%d&quot;, &amp;num)
		if n != 1 || err != nil {
			os.Exit(1)
		}
		// 最后一位给1
		largeNumber[len(largeNumber)-1] = 1
		for i := 1; i &lt;= num; i++ {
			largeNumber = multiplication(largeNumber, i)
		}
		// 数组中不为0的第一个数
		min := 0
		for i := 0; i &lt; len(largeNumber); i++ {
			if largeNumber[i] != 0 {
				min = i
				break
			}
		}
		for i := min; i &lt; len(largeNumber); i++ {
			fmt.Print(largeNumber[i])
		}
		fmt.Println()
	}
}

func multiplication(largeNumber [1000]int, number int) [1000]int {
	for i := 0; i &lt; len(largeNumber); i++ {
		largeNumber[i] = largeNumber[i] * number
	}
	for i := len(largeNumber) - 1; i &gt; 0; i-- {
		// 进位
		largeNumber[i-1] = largeNumber[i]/10 + largeNumber[i-1]
		// 留值
		largeNumber[i] = largeNumber[i] % 10
	}
	return largeNumber
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bubble Sort]]></title>
        <id>https://twFR.github.io/post/bubble-sort/</id>
        <link href="https://twFR.github.io/post/bubble-sort/">
        </link>
        <updated>2019-11-13T12:06:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="需求">需求</h2>
<p>输入带存储单位的数值，排序后输出<br>
1G=1000M；1T=1000G</p>
<h2 id="举例">举例</h2>
<p>（第一行为将要输入的数值个数）<br>
输入：</p>
<blockquote>
<p>3<br>
1G<br>
50M<br>
2T</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>50M<br>
1G<br>
2T</p>
</blockquote>
<h2 id="解题思路">解题思路</h2>
<ul>
<li>用一个底层数组为个数为num的切片放传进来的存储数值</li>
<li>将数值单位转化为对应个数的0，转化后的值作为map的key，转化前的为map的value</li>
<li>冒泡排序将切片排序</li>
<li>遍历切片，拿到map的key，打印对应的value，完事收工</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
)

func main() {
	reader := bufio.NewReader(os.Stdin)
	for {
		input1, _, _ := reader.ReadLine()

		inputLen := len(input1)
		if inputLen == 0 {
			break
		}

		num, _ := strconv.Atoi(string(input1))
		inputArr := make([]string,num)
		memoryMp := make(map[string]string)
		for i := 0; i &lt; num; i++ {
			inputNum, _, _ := reader.ReadLine()
			inputArr[i] = string(inputNum)
		}

		for i := 0; i &lt; num; i++ {
			temp := strings.Replace(inputArr[i], &quot;M&quot;, &quot;&quot;, -1)
			temp = strings.Replace(temp, &quot;G&quot;, &quot;000&quot;, -1)
			temp = strings.Replace(temp, &quot;T&quot;, &quot;000000&quot;, -1)
			memoryMp[temp] = inputArr[i]
			inputArr[i] = temp
		}
		fmt.Println(inputArr)
		fmt.Println(memoryMp)
		for i := 0; i &lt; num; i++ {
			flag := false
			for j := 1; j &lt; num-i; j++ {
				pre, _ := strconv.Atoi(inputArr[j-1])
				next, _ := strconv.Atoi(inputArr[j])
				if pre &gt; next {
					temp := inputArr[j-1]
					inputArr[j-1] = inputArr[j]
					inputArr[j] = temp
					flag = true
				}
			}
			if !flag {
				break
			}
		}
		fmt.Println(&quot;正确的排序为：&quot;)
		fmt.Println(inputArr)
		for i := 0; i &lt; num; i++ {
			fmt.Println(memoryMp[inputArr[i]])
		}
	}
}
</code></pre>
<p>搞定！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thread、Process and Coroutine]]></title>
        <id>https://twFR.github.io/post/threadprocess-and-coroutine/</id>
        <link href="https://twFR.github.io/post/threadprocess-and-coroutine/">
        </link>
        <updated>2019-07-18T02:16:08.000Z</updated>
        <content type="html"><![CDATA[<p>梳理下线程、进程和协程<br>
一句话总结：每个进程有自己独立的地址空间，分享系统资源；线程访问隶属进程资源，同一进程所有线程共享进程所有资源；协程由程序自身控制，在子程序内部可中断。</p>
<h2 id="进程">进程</h2>
<p>一个程序运行就会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间和独立的堆，操作系统会以操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p>
<p>进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；</p>
<h2 id="线程">线程</h2>
<p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。</p>
<p>线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；</p>
<p>在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>
<h2 id="协程">协程</h2>
<p>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>线程默认的栈是8m，而一个协程只需要几十kb</p>
<p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p>
<p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<pre><code>type work struct {
	x, y, z int
}

func worker(in &lt;- chan *work, out chan &lt;-  *work) {
	for w := range in{
		w.z = w.x * w.y
		Sleep(w.z)
		out &lt;- w
	}
	}

func Run()  {
	in , out:= make(chan *work), make(chan *work)
	for i:= 0; i&lt; NumWorks; i++{
		go worker(in, out)
	}
	go sendLotsOfWork(in)
	receiveLotsOfResults(out)

}
</code></pre>
]]></content>
    </entry>
</feed>